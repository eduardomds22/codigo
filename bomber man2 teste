#include <iostream>
#include <windows.h>
#include <conio.h>
#include <cstdlib>
#include <ctime>
#include <thread> ///BIBLIOTECA UTILIZADA PARA FAZER O FUNCIONAMENTO DO CRONOMETRO DA BOMBA
using namespace std;

struct Personagem {
    int x;
    int y;
};

struct Inimigo {
    int a;
    int b;
};
struct Pontuacao {
    int Movimento=0;
    int BombasUsadas=0; //10 pontos
    int InimigosAbatidos=0; // 100 pontos
    int CaixasDestruidas=0; // 10 pontos
    int Pontos=0;
};

bool bombaExiste = false;

void imprimirMapa(const int m[21][40], Personagem jogador, Inimigo inimigo1, Inimigo inimigo2, Inimigo inimigo3, Inimigo inimigo4, COORD coord,Pontuacao PontuacaoJogador1) {
        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);

        //IMPRIME O MAPA E OS PERSONAGENS
        for(int i=0;i<21;i++){
            for(int j=0;j<40;j++){
                if (i == jogador.x && j == jogador.y) {
                cout << char(139); // jogador
            } else if ((i == inimigo1.a && j == inimigo1.b) || (i == inimigo2.a && j == inimigo2.b) || (i == inimigo3.a && j == inimigo3.b) || (i == inimigo4.a && j == inimigo4.b)) {
                cout << char(148); // inimigos
            } else {
                switch (m[i][j]) {
                    case 0: cout << " "; break;
                    case 1: cout << char(219); break;
                    case 2: cout << char(177); break;
                    case 3: cout << char(207); break;
                    case '*': cout << char(158); break;
                }
            }
        }
        cout << "\n";
    }
    cout << "Pontuacao do Jogador 1 \n" << endl;
    cout << "Pontos Adquiridos:" << PontuacaoJogador1.Pontos << endl;
    cout << "Movimentos: " << PontuacaoJogador1.Movimento << endl;
    cout << "Bombas Utilizadas: " << PontuacaoJogador1.BombasUsadas << endl;
    cout << "Inimigos Abatidos: " << PontuacaoJogador1.InimigosAbatidos << endl;
}

bool posicaoOcupadaPelaBomba(int x, int y, int m[21][40]) {
    return (m[x][y] == 3); //CARACTER QUE REPRESENTA A BOMBAE


}

void colocarBomba(int x, int y, int m[21][40]) {
    if (!bombaExiste) {
        m[x][y] = 3;
        bombaExiste = true;
    }
}

void detonarBomba(int x, int y, int m[21][40]) {
    //EXPLOSAO NA POSICAO DA BOMBA
    m[x][y] = '*'; //RAIO DA EXPLOSAO

    //CIMA
    if (x > 0 && m[x - 1][y] != 1) {
        m[x - 1][y] = '*';
        //PontuacaoJogador1.CaixasDestruidas+=10;
    }

    //BAIXO
    if (x < 20 && m[x + 1][y] != 1) {
        m[x + 1][y] = '*';
    }

    //ESQUERDA
    if (y > 0 && m[x][y - 1] != 1) {
        m[x][y - 1] = '*';
    }

    //DIREITA
    if (y < 34 && m[x][y + 1] != 1) {
        m[x][y + 1] = '*';
    }

    bombaExiste = false;

    //ESPERA 1 SEGUNDO PARA A EXPLOSAO SER REMOVIDA
    Sleep(1000);

    //REMOVE A EXPLOSAO
    m[x][y] = 0;
    if (x > 0 && m[x - 1][y] == '*') {
        m[x - 1][y] = 0;
    }
    if (x < 20 && m[x + 1][y] == '*') {
        m[x + 1][y] = 0;
    }
    if (y > 0 && m[x][y - 1] == '*') {
        m[x][y - 1] = 0;
    }
    if (y < 34 && m[x][y + 1] == '*') {
        m[x][y + 1] = 0;
    }
}
void verificarExplosao(int x, int y, Inimigo& inimigo1, Inimigo& inimigo2, Inimigo& inimigo3, Inimigo& inimigo4, int m[21][40],Pontuacao& PontuacaoJogador1) {
    if (m[x][y] == '*') {
        cout << "\n - VOCE PERDEU POIS FOI ATINGIDO PELA EXPLOSAO !!!" << endl;
        exit(0);
    }

    if (m[inimigo1.a][inimigo1.b] == '*') {
        inimigo1.a = 1;
        inimigo1.b = 38;
        PontuacaoJogador1.InimigosAbatidos++;
        PontuacaoJogador1.Pontos+=100;
    }
    if (m[inimigo2.a][inimigo2.b] == '*') {
        inimigo2.a = 7;
        inimigo2.b = 38;
        PontuacaoJogador1.InimigosAbatidos++;
        PontuacaoJogador1.Pontos+=100;
    }
    if (m[inimigo3.a][inimigo3.b] == '*') {
        inimigo3.a = 18;
        inimigo3.b = 38;
        PontuacaoJogador1.InimigosAbatidos++;
        PontuacaoJogador1.Pontos+=100;
    }
    if (m[inimigo4.a][inimigo4.b] == '*') {
        inimigo4.a = 12;
        inimigo4.b = 38;
        PontuacaoJogador1.InimigosAbatidos++;
        PontuacaoJogador1.Pontos+=100;
    }
}

void explosaoAssincrona(int x, int y, int m[21][40]) {
    Sleep(3000); // ESPERA 3 SEGUNDOS PARA EXPLODIR
    detonarBomba(x, y, m);
}
bool verificarVitoria(Inimigo inimigo1, Inimigo inimigo2, Inimigo inimigo3, Inimigo inimigo4) {
    return (inimigo1.a == 1 && inimigo1.b == 38 &&
            inimigo2.a == 7 && inimigo2.b == 38 &&
            inimigo3.a == 18 && inimigo3.b == 38 &&
            inimigo4.a == 12 && inimigo4.b == 38);
}

int main(){

    srand(time(NULL));
    char tecla1;
    int num, escolha, dificuldade=30;
    bool back=false, voltar=false, ganhou=true;
    Pontuacao PontuacaoJogador1;

    while(back==false){
        system("cls");
        voltar=false;
        cout << "_" << endl;
        cout << "     * BEM VINDO AO BOMBERMAN *    " << endl;
        cout << "        |* MENU DE OPCOES *|     \n" << endl;
        cout << "  1 - INICIAR O JOGO               " << endl;
        cout << "  2 - ESCOLHA DA DIFICULDADE       " << endl;
        cout << "  3 - CRIADORES                    " << endl;
        cout << "  4 - TUTORIAL E REGRAS DO JOGO    " << endl;
        cout << "  5 - SAIR DO JOGO                 " << endl;
        cout << "_" << endl;
        cin >> escolha;
        system("cls");


        if(escolha==1){ //INICIA O JOGO
            back=true;
        }
        if(escolha==2){ // ESCOLHA DA DIFICULDADE
                while (voltar==false){
                    cout << "_\n " << endl; // ESCOLHER O TEMPO DE MOVIMENTO DOS INIMIGOS DO JOGO
                    cout << "     |SELECIONE A DIFICULDADE| \n       " << endl;
                    cout << "          1 - FACIL                     " << endl;
                    cout << "          2 - MEDIO                     " << endl;
                    cout << "          3 - DIFICIL\n                 " << endl;
                    cout << "  DIGITE [0] PARA RETORNAR AO MENU\n    " << endl;
                    cout << "_____________________________________   " << endl;
                    cin >> escolha;
                    system("cls");
                    if(escolha == 1){
                        dificuldade=40;
                        cout << "_______________________________________________________________  " << endl;
                        cout << " * DIFICULDADE ALTERADA - VOCE SELECIONOU A DIFICULDADE FACIL *  " << endl;
                        cout << "_______________________________________________________________  " << endl;
                        Sleep(2000);
                        system("cls");
                    }
                    if(escolha == 2){
                        dificuldade=30;
                        cout << "_______________________________________________________________  " << endl;
                        cout << " * DIFICULDADE ALTERADA - VOCE SELECIONOU A DIFICULDADE MEDIA *  " << endl;
                        cout << "_______________________________________________________________  " << endl;
                        Sleep(2000);
                        system("cls");
                    }
                    if(escolha == 3){
                        dificuldade=40;
                        cout << "_______________________________________________________________  " << endl;
                        cout << " * DIFICULDADE ALTERADA - VOCE SELECIONOU A DIFICULDADE FACIL *  " << endl;
                        cout << "_______________________________________________________________  " << endl;
                        Sleep(2000);
                        system("cls");
                    }
                    if(escolha == 0){
                        voltar=true;
                    }
                }
        }
        if (escolha==3){ //INFORMAÇÃO SOBRE ALUNOS E PROFESSOR
            cout << "_______________________________________________________________  " << endl;
            cout << "               * INFORMACAO SOBRE OS CRIADORES * \n             " << endl;
            cout << "                CAIO CARDOSO  -  EDUARDOS MENDES \n              " << endl;
            cout << "                   ALGORITMOS E PROGRAMACAO II \n                " << endl;
            cout << "                    PROFESSOR - ALEX RESE  \n                    " << endl;
            cout << "_______________________________________________________________  " << endl;
            system("pause");
            }
        if (escolha==4){ //REGRAS E TUTORIAL DO JOGO
            cout << "____________________________________________________________________  " << endl;
            cout << "                   * REGRAS DO JOGO E TUTORIAL * \n                   " << endl;
            cout << "     O JOGADOR DEVE USAR AS SEGUINTES TECLAS PARA SE MOVIMENTAR :     " << endl;
            cout << "    A = DIREITA, S = BAIXO, D = ESQUERDA, W = CIMA OU PELAS SETAS \n  " << endl;
            cout << "       O JOGADOR DEVE APERTAR A TECLA ESPAÇO PARA SOLTAR A BOMBA\n    " << endl;
            cout << "   - O JOGADOR GANHA AO PRENDER OS INIMIGOS QUANDO SAO EXPLODIDOS -   " << endl;
            cout << "   -  O JOGADOR NAO PODE SER ATINGIDO PELA BOMBA E NEM SE COLIDIR -   " << endl;
            cout << "____________________________________________________________________  " << endl;
            system("pause");
        }
        if (escolha==5){
           cout << "____________________________________________________________________  " << endl;
           cout << "      !!!    VOCE ENCERROU O JOGO, ATE UMA PROXIMA VEZ   !!!          " << endl;
           cout << "____________________________________________________________________  " << endl;
            return 0;
        }
    }

        //ALERTA: NAO MODIFICAR O TRECHO DE CODIGO, A SEGUIR.
        //INICIO: COMANDOS PARA QUE O CURSOR NAO FIQUE PISCANDO NA TELA
        HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
        CONSOLE_CURSOR_INFO     cursorInfo;
        GetConsoleCursorInfo(out, &cursorInfo);
        cursorInfo.bVisible = false; // set the cursor visibilite
        SetConsoleCursorInfo(out, &cursorInfo);
        //FIM: COMANDOS PARA QUE O CURSOR NAO FIQUE PISCANDO NA TELA
        //INICIO: COMANDOS PARA REPOSICIONAR O CURSOR NO INICIO DA TELA
        short int CX=0, CY=0;
        COORD coord;
        coord.X = CX;
        coord.Y = CY;
        //FIM: COMANDOS PARA REPOSICIONAR O CURSOR NO INICIO DA TELA
        //ALERTA: NAO MODIFICAR O TRECHO DE CODIGO, ACIMA.

int m[21][40] = {   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1},

                    {1,0,0,0,0,2,2,0,2,0,2,2,2,0,2,2,0,2,2,2,0,0,0,0,0,0,0,2,2,2,0,0,0,0,1,0,0,1,0,1},

                    {1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,0,0,0,1,0,0,1,1,1},

                    {1,0,2,2,2,0,0,1,2,2,2,0,1,0,0,2,2,1,2,2,2,2,1,0,0,0,0,1,2,0,0,0,0,0,1,0,0,0,0,0},

                    {1,2,2,0,2,0,0,2,0,2,2,2,2,0,0,2,0,0,2,0,0,0,2,0,2,2,2,2,2,0,0,0,0,2,1,0,0,0,0,0},

                    {1,2,2,0,2,2,2,2,2,2,0,0,2,0,0,2,0,0,2,0,2,2,2,2,0,0,0,0,0,0,0,2,2,2,1,0,0,0,0,0},

                    {1,0,2,0,0,0,0,2,2,0,0,0,2,2,2,0,2,0,0,0,2,2,2,0,0,2,2,2,0,2,0,0,2,0,1,0,0,1,1,1},

                    {1,2,0,2,0,0,0,1,2,0,0,0,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,0,0,2,0,1,0,0,1,0,1},

                    {1,0,2,2,2,2,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,2,2,2,0,0,0,2,0,1,0,0,1,1,1},

                    {1,0,0,0,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,2,2,0,0,2,0,1,0,0,0,0,0},

                    {1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,0,2,2,2,2,2,2,2,2,0,2,1,0,0,0,0,0},

                    {1,0,2,2,2,0,0,1,2,2,2,0,1,2,2,2,2,1,2,2,2,2,1,0,0,0,0,1,2,0,0,0,0,0,1,0,0,1,1,1},

                    {1,2,2,0,2,0,0,2,0,2,2,2,2,0,0,2,0,0,2,0,0,0,2,0,0,2,2,2,2,0,0,0,0,2,1,0,0,1,0,1},

                    {1,2,2,0,2,2,2,2,2,2,0,0,2,0,0,2,0,0,2,0,2,2,2,0,0,0,2,2,0,0,0,2,2,2,1,0,0,1,1,1},

                    {1,0,2,0,0,0,0,2,2,0,0,0,2,2,2,0,2,0,0,0,2,2,2,0,0,2,2,2,0,0,0,0,2,0,1,0,0,0,0,0},

                    {1,2,0,2,0,0,0,1,2,0,0,0,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,0,0,2,0,1,0,0,0,0,0},

                    {1,0,0,2,2,2,2,0,2,2,0,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,2,0,0,2,0,0,2,0,1,0,0,0,0,0},

                    {1,0,0,0,2,0,0,0,0,2,0,0,2,2,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1},

                    {1,0,0,0,0,0,2,0,2,2,0,0,2,0,0,2,2,0,0,0,0,0,2,2,2,2,0,0,0,2,0,0,0,0,1,0,0,1,0,1},

                    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1},};

    //POSICAO INICIAL DOS JOGADORES E INIMIGOS
    Personagem jogador = {18, 1};
    Inimigo inimigo1 = {18, 3}; //{1, 38};
    Inimigo inimigo2 = {7, 38};
    Inimigo inimigo3 = {12, 38};
    Inimigo inimigo4 = {18, 38};


    thread th1, th2, th3, th4, th5;

       // TECLAS A SEREM PRESSIONADAS
    char tecla;
    while(true || ganhou==true){
        imprimirMapa(m, jogador, inimigo1, inimigo2, inimigo3, inimigo4, coord,PontuacaoJogador1); //IMPRIME O MAPA

        if (jogador.x == inimigo1.a && jogador.y == inimigo1.b || jogador.x == inimigo2.a && jogador.y == inimigo2.b || jogador.x == inimigo3.a && jogador.y == inimigo3.b || jogador.x == inimigo4.a && jogador.y == inimigo4.b) { //VERIFICA A COLISAO DOS INIMIGOS COM O USUARIO
            cout << "- VOCE PERDEU POIS FOI ATINGIDO POR UM INIMIGO -" << endl;
            return 0;
        }

        //VERIFICACAO DE VITORIA EM CASO DE EXPLOSAO DOS INIMIGOS
        if (!bombaExiste && verificarVitoria(inimigo1, inimigo2, inimigo3, inimigo4)) {
            cout << "!!! PARABENS, VOCE EXPLODIU TODOS OS INIMIGO E VENCEU O JOGO !!!" << endl;
            return 0;
        }

        //EXECUTA OS MOVIMENTOS DO USUARIO
        if (_kbhit()) {
            tecla = getch();
            switch(tecla) {
                case 72: case 'w': ///CIMA
                    if(m[jogador.x - 1][jogador.y] != 1 && m[jogador.x - 1][jogador.y] != 2 && !posicaoOcupadaPelaBomba(jogador.x - 1, jogador.y, m)) {
                        jogador.x--;
                        PontuacaoJogador1.Movimento++;
                    }
                    break;
                case 80: case 's': ///BAIXO
                    if(m[jogador.x + 1][jogador.y] != 1 && m[jogador.x + 1][jogador.y] != 2 && !posicaoOcupadaPelaBomba(jogador.x + 1, jogador.y, m)) {
                        jogador.x++;
                        PontuacaoJogador1.Movimento++;
                    }
                    break;
                case 75: case 'a': ///ESQUERDA
                    if (m[jogador.x][jogador.y - 1] != 1 && m[jogador.x][jogador.y - 1] != 2 && !posicaoOcupadaPelaBomba(jogador.x, jogador.y - 1, m)) {
                        jogador.y--;
                        PontuacaoJogador1.Movimento++;
                    }
                    break;
                case 77: case 'd': ///DIREITA
                    if (m[jogador.x][jogador.y + 1] != 1 && m[jogador.x][jogador.y + 1] != 2 && !posicaoOcupadaPelaBomba(jogador.x, jogador.y + 1, m)) {
                        jogador.y++;
                        PontuacaoJogador1.Movimento++;
                    }
                    break;
                case 32: /// ESPAÇO PARA COLOCACAO DA BOMBA
                    if (!bombaExiste) {
                        colocarBomba(jogador.x, jogador.y, m);
                        bombaExiste = true;
                        PontuacaoJogador1.BombasUsadas++;
                        PontuacaoJogador1.Pontos+=10;
                        thread t(explosaoAssincrona, jogador.x, jogador.y, m);
                        t.detach(); // DESANEXA A THREAD
                    }
                    break;
            }
        }

        ///MOVIMENTACAO DOS INIMIGOS - IMPEDE COLISAO COM PAREDES E A POSICAO QUE A BOMBA OCUPA ANTES DE SER EXPLODIDA
        // Movimento do inimigo 1

/*
        int MovimentoAleatorio1 = rand() % dificuldade + 1;
        switch(MovimentoAleatorio1) {
            case 1:
                if(m[inimigo1.a - 1][inimigo1.b] != 1 && m[inimigo1.a - 1][inimigo1.b] != 2 && !posicaoOcupadaPelaBomba(inimigo1.a - 1, inimigo1.b, m)) {
                    inimigo1.a--;
                }
                break;
            case 2:
                if(m[inimigo1.a + 1][inimigo1.b] != 1 && m[inimigo1.a + 1][inimigo1.b] != 2 && !posicaoOcupadaPelaBomba(inimigo1.a + 1, inimigo1.b, m)) {
                    inimigo1.a++;
                }
                break;
            case 3:
                if (m[inimigo1.a][inimigo1.b - 1] != 1 && m[inimigo1.a][inimigo1.b - 1] != 2 && !posicaoOcupadaPelaBomba(inimigo1.a, inimigo1.b - 1, m)) {
                    inimigo1.b--;
                }
                break;
            case 4:
                if (m[inimigo1.a][inimigo1.b + 1] != 1 && m[inimigo1.a][inimigo1.b + 1] != 2 && !posicaoOcupadaPelaBomba(inimigo1.a, inimigo1.b + 1, m)) {
                    inimigo1.b++;
                }
                break;
        }
*/
        // Movimento do inimigo 2
        int MovimentoAleatorio2 = rand() % dificuldade + 1;
        switch(MovimentoAleatorio2) {
            // casos para o movimento do inimigo 2
        }
        // Movimento do inimigo 3
        int MovimentoAleatorio3 = rand() % dificuldade + 1;
        switch(MovimentoAleatorio3) {
            // casos para o movimento do inimigo 3
        }
        // Movimento do inimigo 4
        int MovimentoAleatorio4 = rand() % dificuldade + 1;
        switch(MovimentoAleatorio4) {
            // casos para o movimento do inimigo 4
        }

        ///SEGUNDA VERIFICACAO DE COLISAO APOS A MOVIMENTCAO
        if (inimigo1.a == jogador.x && inimigo1.b == jogador.y || inimigo2.a == jogador.x && inimigo2.b == jogador.y || inimigo3.a == jogador.x && inimigo3.b == jogador.y || inimigo4.a == jogador.x && inimigo4.b == jogador.y) {
            ganhou = false;
        }

        ///VERIFICA SE OS INIMIGOS FORAM ATINGIDOS PELO RAIO DA BOMBA
        verificarExplosao(jogador.x, jogador.y, inimigo1, inimigo2, inimigo3, inimigo4, m,PontuacaoJogador1);
    }

    return 0;
}
